<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Coap分块传输(2)</title>
    <link href="/posts/a23fc180.html"/>
    <url>/posts/a23fc180.html</url>
    
    <content type="html"><![CDATA[<h1 id="Coap分块传输-2"><a href="#Coap分块传输-2" class="headerlink" title="Coap分块传输(2)"></a>Coap分块传输(2)</h1><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>CoAP（Constrained Application Protocol）的分块传输机制（Block-wise Transfer）是解决大文件传输问题的核心功能。<br>可以用来实现固件更新和大文件传输。</p><h2 id="两种模式"><a href="#两种模式" class="headerlink" title="两种模式"></a>两种模式</h2><p>1.上传模式：客户端使用PUT&#x2F;POST方法，分块上传数据到服务器<br>2.下载模式：客户端使用GET方法，请求服务器数据，服务器在响应中返回分块数据</p><h2 id="分块传输选项"><a href="#分块传输选项" class="headerlink" title="分块传输选项"></a>分块传输选项</h2><p>CoAP 分块传输选项（Block Option）用于在请求和响应中携带分块信息，包括块大小、块数量、块偏移等。<br>通过这些选项，客户端和服务器可以协商分块传输的参数，实现高效的数据传输。</p><h3 id="Block选项"><a href="#Block选项" class="headerlink" title="Block选项"></a>Block选项</h3><p>Block1：用于请求（Request）中的分块上传（如PUT&#x2F;POST），表示客户端正在发送的数据块。<br>Block2：用于响应（Response）中的分块下载（如GET），表示服务器正在返回的数据块。</p><p>每个Block选项包含三个关键字段：</p><ul><li>SZX（Size Extension）：2位，表示块大小的指数（范围0-6），计算公式为<br><code>块大小 = 16 * 2^SZX（即16~1024字节）</code>。</li><li>M（More Flag）：1位，表示是否还有后续块（1&#x3D;有，0&#x3D;无）。</li><li>NUM（Number）：块编号（从0开始递增），表示当前块在整个数据中的位置。</li></ul><h3 id="Size选项"><a href="#Size选项" class="headerlink" title="Size选项"></a>Size选项</h3><p>Size1：客户端在请求中声明的总数据大小（仅用于上传场景）。<br>Size2：服务器在响应中声明的总数据大小（仅用于下载场景）。</p><h2 id="传输流程"><a href="#传输流程" class="headerlink" title="传输流程"></a>传输流程</h2><h3 id="下载场景（GET请求）"><a href="#下载场景（GET请求）" class="headerlink" title="下载场景（GET请求）"></a>下载场景（GET请求）</h3><ul><li><p>客户端发起请求：<br>在GET请求中携带 Block2 选项，设置 NUM&#x3D;0、M&#x3D;0、SZX&#x3D;期望块大小，表示希望以指定块大小下载数据。<br>示例：Block2: NUM&#x3D;0, M&#x3D;0, SZX&#x3D;4（块大小&#x3D;128字节）。</p></li><li><p>服务器响应：<br>返回第一个数据块，携带 Block2 选项，设置 NUM&#x3D;0、M&#x3D;1（表示还有更多块）、SZX&#x3D;实际块大小。<br>可选携带 Size2 选项，告知客户端总数据大小。<br>示例：Block2: NUM&#x3D;0, M&#x3D;1, SZX&#x3D;4，Size2: 1024。</p></li><li><p>客户端继续请求：<br>根据服务器返回的 Block2 中的 NUM 值递增（NUM+1），发送新的GET请求，携带更新的 Block2 选项。<br>示例：Block2: NUM&#x3D;1, M&#x3D;0, SZX&#x3D;4。</p></li><li><p>服务器继续响应：<br>返回后续块，直到 M&#x3D;0 表示传输完成。</p></li></ul><h3 id="上传场景（PUT-x2F-POST请求）"><a href="#上传场景（PUT-x2F-POST请求）" class="headerlink" title="上传场景（PUT&#x2F;POST请求）"></a>上传场景（PUT&#x2F;POST请求）</h3><ul><li><p>客户端发送第一个块：<br>在请求中携带 Block1 选项，设置 NUM&#x3D;0、M&#x3D;1、SZX&#x3D;块大小，并附带第一个数据块。<br>可选携带 Size1 选项，声明总数据大小。<br>示例：Block1: NUM&#x3D;0, M&#x3D;1, SZX&#x3D;4，Size1: 1024。</p></li><li><p>服务器响应：<br>返回确认（ACK）或中间状态码（如2.04 Changed），并携带 Block1 选项，设置 M&#x3D;1（表示需要更多块）。<br>示例：Block1: NUM&#x3D;0, M&#x3D;1, SZX&#x3D;4。</p></li><li><p>客户端发送后续块：<br>根据 Block1 中的 NUM 值递增（NUM+1），发送下一个块，并更新 M 标志（最后一个块设为 M&#x3D;0）。</p></li><li><p>服务器最终响应：<br>当所有块接收完成后，返回最终响应（如2.04 Changed），并设置 M&#x3D;0。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术栈</category>
      
      <category>IoT</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式技术趋势-2025</title>
    <link href="/posts/a4a70644.html"/>
    <url>/posts/a4a70644.html</url>
    
    <content type="html"><![CDATA[<h1 id="嵌入式技术趋势-2025"><a href="#嵌入式技术趋势-2025" class="headerlink" title="嵌入式技术趋势-2025"></a>嵌入式技术趋势-2025</h1><h2 id="技术趋势"><a href="#技术趋势" class="headerlink" title="技术趋势"></a>技术趋势</h2><h3 id="1-智能化"><a href="#1-智能化" class="headerlink" title="1. 智能化"></a>1. 智能化</h3><p>随着人工智能的快速发展，嵌入式系统正逐步集成更多智能化功能。例如，边缘AI（Edge AI）正在成为物联网终端、工业自动化、智能家居等领域的核心驱动力。嵌入式设备不仅可以本地进行数据分析和决策，还能实现自适应和自主学习，推动“设备智能”向“系统智能”演进。</p><h3 id="2-网联化"><a href="#2-网联化" class="headerlink" title="2. 网联化"></a>2. 网联化</h3><p>万物互联的时代已然到来，嵌入式设备的网络连接能力成为基础要求。新一代通信协议（如5G、Wi-Fi 6、Matter等）被广泛应用，推动嵌入式设备实现云端协同、远程维护和OTA升级。智能网关、边缘计算等技术也在加速嵌入式系统的网络化升级。</p><h3 id="3-安全性"><a href="#3-安全性" class="headerlink" title="3. 安全性"></a>3. 安全性</h3><p>随着嵌入式设备的广泛联网和智能化，安全威胁显著增加。数据加密、安全启动、可信执行环境等安全机制正在成为嵌入式系统设计的标配。合规与认证（如GDPR、ISO 26262等）也对嵌入式安全提出更高要求，无论是硬件还是软件层面，安全性都成为核心竞争力。</p><h3 id="4-低功耗"><a href="#4-低功耗" class="headerlink" title="4. 低功耗"></a>4. 低功耗</h3><p>绿色节能和移动应用需求推动低功耗技术持续创新。超低功耗MCU、动态电源管理、多级休眠、能效算法等技术不断涌现。低功耗设计不仅延长了电池寿命，也为无源设备、可穿戴设备、环境监测等新兴场景提供了可能。</p><h2 id="值得关注的新技术"><a href="#值得关注的新技术" class="headerlink" title="值得关注的新技术"></a>值得关注的新技术</h2><h3 id="1-TinyML"><a href="#1-TinyML" class="headerlink" title="1. TinyML"></a>1. TinyML</h3><p>TinyML指在资源受限的嵌入式设备上运行机器学习模型。通过优化模型结构、量化权重和高效硬件支持，TinyML使AI算法能够在微控制器（如Cortex-M系列）等极小型芯片上实现实时推理，广泛应用于语音识别、图像分类、异常检测等场景。</p><h3 id="2-RISC-V"><a href="#2-RISC-V" class="headerlink" title="2. RISC-V"></a>2. RISC-V</h3><p>RISC-V作为开源指令集架构，凭借其高度可扩展性和灵活性，受到嵌入式领域的广泛关注。RISC-V生态持续壮大，相关芯片、开发板和工具链日益丰富。它不仅降低了芯片设计门槛，还为专用加速器和安全机制的定制化开辟了新路径。</p><h3 id="3-多核异构"><a href="#3-多核异构" class="headerlink" title="3. 多核异构"></a>3. 多核异构</h3><p>多核异构架构（Heterogeneous Multi-core）通过集成不同类型的CPU、DSP、NPU、FPGA等处理单元，实现任务的最优分配与加速。该技术极大提升了嵌入式系统的计算效率和能效比，在自动驾驶、智能视觉、边缘AI等场景表现突出。</p><h3 id="4-TrustZone"><a href="#4-TrustZone" class="headerlink" title="4. TrustZone"></a>4. TrustZone</h3><p>ARM TrustZone为嵌入式设备提供硬件隔离的安全执行环境。它通过将系统划分为安全域和非安全域，实现安全启动、密钥管理和受信任应用的独立运行。TrustZone已成为物联网、支付终端等对安全性要求高的应用的首选方案。</p><h3 id="5-Zephyr"><a href="#5-Zephyr" class="headerlink" title="5. Zephyr"></a>5. Zephyr</h3><p>Zephyr是一款轻量级、模块化的开源实时操作系统（RTOS），专为资源受限的嵌入式设备设计。它支持多种架构（包括ARM、RISC-V等），具有高可移植性和丰富的中间件组件，适用于物联网、可穿戴、传感器网络等多样化应用。</p><h3 id="6-Rust"><a href="#6-Rust" class="headerlink" title="6. Rust"></a>6. Rust</h3><p>Rust语言以“安全、并发、性能”为核心，逐步进入嵌入式开发领域。Rust的零成本抽象与内存安全特性，有效减少了嵌入式系统中的常见漏洞（如空指针、缓冲区溢出），正在成为新一代高可靠嵌入式软件开发的重要选择。</p><h3 id="7-能量收集"><a href="#7-能量收集" class="headerlink" title="7. 能量收集"></a>7. 能量收集</h3><p>能量收集（Energy Harvesting）技术通过太阳能、热能、振动、射频等环境能量为嵌入式设备供电，极大延长了设备的工作寿命。该技术使无源、超低功耗、长寿命的嵌入式应用成为可能，广泛应用于无线传感器网络、可穿戴设备、远程监测等场景，推动了真正意义上的“自供能”物联网终端发展。</p>]]></content>
    
    
    <categories>
      
      <category>应用面</category>
      
      <category>技术趋势</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Coap协议理解(1)</title>
    <link href="/posts/970739ef.html"/>
    <url>/posts/970739ef.html</url>
    
    <content type="html"><![CDATA[<h1 id="Coap协议理解-1"><a href="#Coap协议理解-1" class="headerlink" title="Coap协议理解(1)"></a>Coap协议理解(1)</h1><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>CoAP（Constrained Application Protocol，受限应用协议）是一种专为资源受限的物联网设备（如低功耗传感器、嵌入式微控制器）设计的轻量级应用层协议。</p><h2 id="核心特点"><a href="#核心特点" class="headerlink" title="核心特点"></a>核心特点</h2><h3 id="1-报文格式精简"><a href="#1-报文格式精简" class="headerlink" title="1. 报文格式精简"></a>1. 报文格式精简</h3><p>使用二进制编码形式，固定报文头仅有4个字节</p><h3 id="2-传输层基于UDP"><a href="#2-传输层基于UDP" class="headerlink" title="2. 传输层基于UDP"></a>2. 传输层基于UDP</h3><p>基于UDP，支持多播；应用层增加响应和重传机制，保证可靠传输</p><h3 id="3-使用RESTful架构"><a href="#3-使用RESTful架构" class="headerlink" title="3. 使用RESTful架构"></a>3. 使用RESTful架构</h3><p>使用和HTTP类似的请求-响应模式，支持GET、POST、PUT、DELETE等操作</p><h2 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h2><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br><span class="hljs-code">+--------+</span>--------<span class="hljs-code">+--------+</span>--------+<br><span class="hljs-section">|Ver| T |TKL|  Code   |   Message ID   |</span><br><span class="hljs-section">+--------+--------+--------+--------+</span><br><span class="hljs-section">|   Token (if any, TKL bytes)        |</span><br><span class="hljs-section">+--------+--------+--------+--------+</span><br><span class="hljs-section">|   Options (if any)                 |</span><br><span class="hljs-section">+--------+--------+--------+--------+</span><br><span class="hljs-section">|1 byte: 0xFF (if payload present)   |</span><br><span class="hljs-section">+--------+--------+--------+--------+</span><br><span class="hljs-section">|   Payload (if any)                 |</span><br><span class="hljs-section">+--------+--------+--------+--------+</span><br><br></code></pre></td></tr></table></figure><p>整个报文由四部分组成：</p><h3 id="1-Header"><a href="#1-Header" class="headerlink" title="1. Header"></a>1. Header</h3><p><strong>(1) 版本号（Ver）</strong></p><p>2位：表示CoAP协议版本，当前固定值为 01（即版本1.0）。<br>作用：确保兼容性，避免不同版本协议冲突。</p><p><strong>(2) 消息类型（T）</strong></p><p>2位：定义4种消息类型，控制通信的可靠性：</p><table><thead><tr><th>类型</th><th>编码</th><th>说明</th></tr></thead><tbody><tr><td>CON</td><td>00</td><td>可确认消息（Confirmable）：需接收方确认（ACK），适用于关键数据传输（如配置更新）。</td></tr><tr><td>NON</td><td>01</td><td>不可确认消息（Non-confirmable）：无需确认，适用于容忍丢包的场景（如传感器数据上报）。</td></tr><tr><td>ACK</td><td>10</td><td>确认消息（Acknowledgement）：响应CON消息的确认。</td></tr><tr><td>RST</td><td>11</td><td>复位消息（Reset）：用于异常终止通信（如服务器无法处理CON消息时返回）。</td></tr></tbody></table><p><strong>(3) 标签长度（TKL）</strong></p><p>4位：指示 Token字段 的长度（0~4字节），取值范围为 0b0000（0字节）到 0b0100（4字节）。<br>Token的作用：用于关联请求与响应，防止重复请求和响应匹配错误。</p><p><strong>(4) 功能码&#x2F;响应码（Code）</strong></p><p>8位：分为 请求码 和 响应码</p><table><thead><tr><th>Code字段</th><th>十进制</th><th>类型</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>0.00</td><td>0</td><td>空</td><td>Empty</td><td>空消息</td></tr><tr><td>0.01</td><td>1</td><td>请求</td><td>GET</td><td>获取资源</td></tr><tr><td>0.02</td><td>2</td><td>请求</td><td>POST</td><td>创建或处理资源</td></tr><tr><td>0.03</td><td>3</td><td>请求</td><td>PUT</td><td>更新&#x2F;替换资源</td></tr><tr><td>0.04</td><td>4</td><td>请求</td><td>DELETE</td><td>删除资源</td></tr><tr><td>2.01</td><td>65</td><td>成功响应</td><td>Created</td><td>成功创建资源</td></tr><tr><td>2.02</td><td>66</td><td>成功响应</td><td>Deleted</td><td>成功删除资源</td></tr><tr><td>2.03</td><td>67</td><td>成功响应</td><td>Valid</td><td>响应有效</td></tr><tr><td>2.04</td><td>68</td><td>成功响应</td><td>Changed</td><td>成功修改资源</td></tr><tr><td>2.05</td><td>69</td><td>成功响应</td><td>Content</td><td>成功返回资源内容</td></tr><tr><td>2.31</td><td>95</td><td>成功响应(扩展)</td><td>Continue</td><td>分块传输的中间响应（RFC 7959）</td></tr><tr><td>4.00</td><td>128</td><td>客户端错误</td><td>Bad Request</td><td>请求格式错误</td></tr><tr><td>4.01</td><td>129</td><td>客户端错误</td><td>Unauthorized</td><td>未授权</td></tr><tr><td>4.02</td><td>130</td><td>客户端错误</td><td>Bad Option</td><td>不支持的选项</td></tr><tr><td>4.03</td><td>131</td><td>客户端错误</td><td>Forbidden</td><td>被禁止</td></tr><tr><td>4.04</td><td>132</td><td>客户端错误</td><td>Not Found</td><td>找不到资源</td></tr><tr><td>4.05</td><td>133</td><td>客户端错误</td><td>Method Not Allowed</td><td>方法不允许</td></tr><tr><td>4.06</td><td>134</td><td>客户端错误</td><td>Not Acceptable</td><td>不可接受的内容</td></tr><tr><td>4.08</td><td>136</td><td>客户端错误</td><td>Request Entity Incomplete</td><td>请求实体不完整</td></tr><tr><td>4.09</td><td>137</td><td>客户端错误(扩展)</td><td>Conflict</td><td>资源冲突（RFC 8132）</td></tr><tr><td>4.12</td><td>140</td><td>客户端错误</td><td>Precondition Failed</td><td>前置条件失败</td></tr><tr><td>4.13</td><td>141</td><td>客户端错误</td><td>Request Entity Too Large</td><td>请求体过大</td></tr><tr><td>4.15</td><td>143</td><td>客户端错误</td><td>Unsupported Content-Format</td><td>不支持的内容格式</td></tr><tr><td>5.00</td><td>160</td><td>服务器错误</td><td>Internal Server Error</td><td>服务器内部错误</td></tr><tr><td>5.01</td><td>161</td><td>服务器错误</td><td>Not Implemented</td><td>未实现</td></tr><tr><td>5.02</td><td>162</td><td>服务器错误</td><td>Bad Gateway</td><td>网关错误</td></tr><tr><td>5.03</td><td>163</td><td>服务器错误</td><td>Service Unavailable</td><td>服务不可用</td></tr><tr><td>5.04</td><td>164</td><td>服务器错误</td><td>Gateway Timeout</td><td>网关超时</td></tr><tr><td>5.05</td><td>165</td><td>服务器错误</td><td>Proxying Not Supported</td><td>不支持代理</td></tr></tbody></table><p><strong>(5) 报文ID（Message ID）</strong></p><p>16位：唯一标识每个CoAP消息，用于 重传和确认机制，确保消息顺序正确。</p><h3 id="2-Token-可选"><a href="#2-Token-可选" class="headerlink" title="2. Token(可选)"></a>2. Token(可选)</h3><p>长度由TKL指定（0~4字节）：用于匹配请求与响应，避免多线程或并发请求的混淆。</p><h3 id="3-Options-可选"><a href="#3-Options-可选" class="headerlink" title="3. Options(可选)"></a>3. Options(可选)</h3><p>以TLV（类型-长度-值）格式编码，描述如URI、Content-Format等参数。Tag采用紧凑编码（Delta-Value编码）减少开销。<br>格式：<br>Option Delta：表示当前选项编号与前一个选项编号的差值。<br>Option Length：表示选项值的长度。<br>Option Value：实际选项值（如URI路径、内容类型）。</p><h3 id="4-Payload-可选"><a href="#4-Payload-可选" class="headerlink" title="4. Payload(可选)"></a>4. Payload(可选)</h3><p>Payload Marker（负载标记，1字节，0xFF）<br>如果有负载，则用0xFF（1字节）作为标记，标记后面就是负载内容。如果没有负载则省略。<br>Payload（负载，可变长度）<br>实际传输的数据内容。</p><h2 id="通信机制"><a href="#通信机制" class="headerlink" title="通信机制"></a>通信机制</h2><h3 id="1-请求-x2F-响应"><a href="#1-请求-x2F-响应" class="headerlink" title="1. 请求&#x2F;响应"></a>1. 请求&#x2F;响应</h3><p>客户端使用GET\PUT\POST\DELETE等请求方法，在选项中携带URI、Content-Format等参数，Payload中携带数据， 发送请求给服务器。<br>服务器收到请求后，处理请求，返回响应。响应中携带响应码、选项、负载等。</p><p>同步请求&#x2F;响应：客户端发送CON请求，服务器以ACK应答。<br>异步请求&#x2F;响应：如需较长时间处理，可先ACK确认收到请求，后续再发送响应。</p><h3 id="2-重传机制"><a href="#2-重传机制" class="headerlink" title="2. 重传机制"></a>2. 重传机制</h3><p>仅对Confirmable（CON，可确认）消息进行重传。<br>客户端发送一个CON消息，等待ACK确认。<br>如果客户端在超时时间内未收到ACK，会重传CON消息，最多重传N次。<br>这个超时时间的计算采用指数退避算法，初始超时时间为2秒，每次重传时，超时时间加倍。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><br>第i次重传等待时间 = ACK_TIMEOUT × (2^(i-1)) × ACK_RANDOM_FACTOR<br><br>ACK<span class="hljs-emphasis">_TIMEOUT：初始超时时间（例如2秒）</span><br><span class="hljs-emphasis">ACK_RANDOM_FACTOR：随机因子,用来防止网络中大量设备在同一时刻同时重传消息，造成网络拥塞或“碰撞”</span><br><span class="hljs-emphasis">通常是一个在一定范围内的浮点数（比如介于1.0和1.5之间），每次重传时由设备随机选择</span><br><span class="hljs-emphasis">MAX_</span>RETRANSMIT：最大重传次数（通常为4次）<br><br></code></pre></td></tr></table></figure><h3 id="3-分块传输"><a href="#3-分块传输" class="headerlink" title="3. 分块传输"></a>3. 分块传输</h3><p>CoAP的分块传输机制通过Block1和Block2选项，将大数据分成多个小块顺序传输，可用于固件传输或大文件传输。<br>支持两种方式进行：</p><ol><li>客户端发送POST请求，带上Block1选项，将数据放到Payload中，分块发送给服务器。</li><li>客户端发送GET请求，带上Block2选项，服务器返回数据时，带上Block2选项，将数据放到Payload中，分块返回给客户端。</li></ol><h3 id="4-多播传输"><a href="#4-多播传输" class="headerlink" title="4. 多播传输"></a>4. 多播传输</h3><p>CoAP协议基于UDP，UDP本身支持IP多播。<br>CoAP客户端将请求发送到一个特定的多播IP地址，网络中所有监听该多播组的CoAP服务器都能收到请求。</p><h3 id="5-观察模式"><a href="#5-观察模式" class="headerlink" title="5. 观察模式"></a>5. 观察模式</h3><p>CoAP协议支持观察模式，客户端可以订阅服务器的某个资源，服务器会定期向客户端推送资源变化。</p><h3 id="6-安全机制"><a href="#6-安全机制" class="headerlink" title="6. 安全机制"></a>6. 安全机制</h3><p>CoAP协议支持DTLS安全机制，基于UDP的TLS，用于保护通信安全。</p>]]></content>
    
    
    <categories>
      
      <category>技术栈</category>
      
      <category>IoT</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Micrium OS查询线程总数</title>
    <link href="/posts/9d3d25d4.html"/>
    <url>/posts/9d3d25d4.html</url>
    
    <content type="html"><![CDATA[<h1 id="Micrium-OS查询线程总数"><a href="#Micrium-OS查询线程总数" class="headerlink" title="Micrium OS查询线程总数"></a>Micrium OS查询线程总数</h1><h2 id="1-使用os-h里的全局变量"><a href="#1-使用os-h里的全局变量" class="headerlink" title="1. 使用os.h里的全局变量"></a>1. 使用<code>os.h</code>里的全局变量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">// OSTaskDbgListPtr 是一个用于调试目的的任务链表指针,指向内核维护的任务链表</span><br><span class="hljs-comment">// 通过遍历这个指针，即可获取所有任务信息</span><br>OS_EXT OS_TCB *OSTaskDbgListPtr;<br><br><span class="hljs-comment">// 记录所有已创建任务的数量</span><br>OS_EXT OS_OBJ_QTY OSTaskQty;                                  <br><br><br></code></pre></td></tr></table></figure><h2 id="2-使用CMSIS-RTOS2的接口，本质也是遍历任务链表"><a href="#2-使用CMSIS-RTOS2的接口，本质也是遍历任务链表" class="headerlink" title="2. 使用CMSIS-RTOS2的接口，本质也是遍历任务链表"></a>2. 使用CMSIS-RTOS2的接口，本质也是遍历任务链表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><br><span class="hljs-type">uint32_t</span>  <span class="hljs-title function_">osThreadGetCount</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (CORE_InIrqContext() == <span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0u</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-type">uint32_t</span>)OSTaskQty;<br>&#125;<br><br><span class="hljs-type">uint32_t</span>  <span class="hljs-title function_">osThreadEnumerate</span><span class="hljs-params">(osThreadId_t   *thread_array,</span><br><span class="hljs-params">                            <span class="hljs-type">uint32_t</span>       array_items)</span><br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> (OS_CFG_DBG_EN == DEF_ENABLED)</span><br>  OS_TCB   *p_tcb;<br>  <span class="hljs-type">uint32_t</span>  items;<br><br>  <span class="hljs-keyword">if</span> (CORE_InIrqContext() == <span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0u</span>;<br>  &#125;<br>  items = <span class="hljs-number">0u</span>;<br><br>  CORE_DECLARE_IRQ_STATE;<br>  CORE_ENTER_CRITICAL();<br>  p_tcb = OSTaskDbgListPtr;<br>  <span class="hljs-keyword">while</span> ((p_tcb != (OS_TCB *)<span class="hljs-number">0</span>) &amp;&amp; (items &lt; array_items)) &#123;<br>    *thread_array = p_tcb;<br>    thread_array++;<br>    p_tcb = p_tcb-&gt;DbgNextPtr;<br>    items++;<br>  &#125;<br>  CORE_EXIT_CRITICAL();<br>  <span class="hljs-keyword">return</span> items;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>  (<span class="hljs-type">void</span>)thread_array;<br>  (<span class="hljs-type">void</span>)array_items;<br>  RTOS_ASSERT_CRITICAL(DEF_FALSE, RTOS_ERR_NOT_AVAIL, <span class="hljs-number">0u</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0u</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">print_thread_info</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">uint32_t</span> maxThreads = osThreadGetCount();<br>  <span class="hljs-keyword">if</span> (maxThreads &gt; <span class="hljs-number">0</span>)<br>  &#123;<br>    osThreadId_t *threadList = <span class="hljs-built_in">malloc</span>(maxThreads * <span class="hljs-keyword">sizeof</span>(osThreadId_t));<br>    <span class="hljs-keyword">if</span> (threadList != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      <span class="hljs-type">uint32_t</span> actualCount = osThreadEnumerate(threadList, maxThreads);<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nThread Information:\n&quot;</span>);<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%-20s %3s %-12s %6s %9s\n&quot;</span>,<br>             <span class="hljs-string">&quot;Name&quot;</span>, <span class="hljs-string">&quot;Pri&quot;</span>, <span class="hljs-string">&quot;Status&quot;</span>, <span class="hljs-string">&quot;Stack(*4 bytes)&quot;</span>, <span class="hljs-string">&quot;Max_Used(*4 bytes)&quot;</span>);<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;--------------------------------------------------------\n&quot;</span>);<br><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; actualCount; i++)<br>      &#123;<br>        OS_TCB *tcb = (OS_TCB *)threadList[i];<br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span> *threadName = osThreadGetName(threadList[i]);<br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span> *state_str = <span class="hljs-string">&quot;Unknown&quot;</span>;<br><br>        <span class="hljs-comment">// 转换任务状态为可读字符串</span><br>        <span class="hljs-keyword">switch</span> (tcb-&gt;TaskState)<br>        &#123;<br>        <span class="hljs-keyword">case</span> OS_TASK_STATE_RDY:<br>          state_str = <span class="hljs-string">&quot;Ready&quot;</span>;<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> OS_TASK_STATE_DLY:<br>          state_str = <span class="hljs-string">&quot;Delayed&quot;</span>;<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> OS_TASK_STATE_PEND:<br>          state_str = <span class="hljs-string">&quot;Pending&quot;</span>;<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> OS_TASK_STATE_SUSPENDED:<br>          state_str = <span class="hljs-string">&quot;Suspended&quot;</span>;<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> OS_TASK_STATE_PEND_SUSPENDED:<br>          state_str = <span class="hljs-string">&quot;Pend+Susp&quot;</span>;<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%-25s %3u %-12s %6u %9u\n&quot;</span>,<br>               threadName ? threadName : <span class="hljs-string">&quot;UNKNOWN&quot;</span>,<br>               tcb-&gt;Prio,<br>               state_str,<br>               tcb-&gt;StkSize,<br>               tcb-&gt;StkUsed);<br>      &#125;<br>      <span class="hljs-built_in">free</span>(threadList);<br>    &#125;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工程链</category>
      
      <category>问题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>树莓派OS不支持pip</title>
    <link href="/posts/6b958691.html"/>
    <url>/posts/6b958691.html</url>
    
    <content type="html"><![CDATA[<h1 id="树莓派OS不支持pip"><a href="#树莓派OS不支持pip" class="headerlink" title="树莓派OS不支持pip"></a>树莓派OS不支持pip</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>Raspberry Pi OS 新版本 Bookworm 不支持使用<code>pip</code>安装软件包，提示和系统包管理工具冲突</p><img src="/posts/6b958691/pip.jpg" class="" title="图片说明"><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>使用python内置的虚拟环境管理工具<code>venv</code>，创建独立的python运行环境。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-comment"># 创建虚拟环境</span><br>python -m venv myenv  <span class="hljs-comment"># 创建名为myenv的虚拟环境</span><br><span class="hljs-comment"># --system-site-packages：允许访问全局安装的包（默认隔离）</span><br><br><span class="hljs-comment"># 激活虚拟环境</span><br>source myenv/<span class="hljs-built_in">bin</span>/activate  <span class="hljs-comment"># Linux</span><br>myenv\Scripts\activate    <span class="hljs-comment"># Windows</span><br><br><span class="hljs-comment"># 退出虚拟环境</span><br>deactivate  <span class="hljs-comment"># 所有系统通用</span><br><br><span class="hljs-comment"># 删除虚拟环境</span><br>rm -rf myenv  <span class="hljs-comment"># Linux</span><br><br>pip freeze &gt; requirements.txt  <span class="hljs-comment"># 导出依赖清单</span><br>pip install -r requirements.txt  <span class="hljs-comment"># 根据清单安装</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工程链</category>
      
      <category>问题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Git-patch使用</title>
    <link href="/posts/921aa84f.html"/>
    <url>/posts/921aa84f.html</url>
    
    <content type="html"><![CDATA[<h1 id="Git-patch使用"><a href="#Git-patch使用" class="headerlink" title="Git-patch使用"></a>Git-patch使用</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在 Git 中，Patch（补丁） 是一种用于记录和描述代码变更的文本文件。<br>它本质上是文件修改的“差异”（diff），可以将这些差异提取出来，并应用到其他代码仓库或分支中。<br>Patch 的核心作用是保存和传播代码的修改，常用于协作开发、跨仓库同步、提交审查等场景。</p><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><ul><li><p>跨仓库同步修改</p><p>  当无法直接拉取远程分支时（如权限限制），可以通过生成 Patch 文件将修改应用到其他仓库。</p></li><li><p>协作开发</p><p>  开发者可以将修改生成 Patch 文件，通过邮件或代码审查工具分享给他人，便于讨论和集成。</p></li><li><p>备份和恢复</p><p>  在提交前，可以通过 Patch 文件备份未提交的修改，避免意外丢失。</p></li><li><p>历史回溯</p><p>  通过应用旧的 Patch 文件，可以快速恢复或测试特定版本的修改。</p></li></ul><h2 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h2><p>1.生成单个提交的 Patch</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>使用 git format-patch<br>git format-patch -1 &lt;commit-hash&gt;<br>生成最近一次提交的 Patch 文件（例如 0001-Add-new-feature.patch）。<br><br>使用 git diff：<br>git diff HEAD~1 &gt; my_patch.patch<br><br></code></pre></td></tr></table></figure><p>2.生成多个提交的 Patch 序列</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>生成指定范围内的所有提交：<br>git format-patch &lt;start-commit&gt;..&lt;end-commit&gt;<br><br>例如：git format-patch abc1234..def5678 会生成从 abc1234 到 def5678 的所有提交的 Patch 文件。<br><br>生成最近的 N 个提交：<br>git format-patch -N<br>例如：git format-patch -3 生成最近三个提交的 Patch。<br><br></code></pre></td></tr></table></figure><p>3.生成未提交的修改为 Patch</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>生成工作区的修改：<br>git diff &gt; my_changes.patch<br><br>生成暂存区的修改：<br>git diff --cached &gt; staged.patch<br><br></code></pre></td></tr></table></figure><h2 id="打补丁"><a href="#打补丁" class="headerlink" title="打补丁"></a>打补丁</h2><p>1.使用 git apply</p><p>仅应用修改，不创建提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>git apply my_patch.patch<br>如果应用成功，修改会直接出现在工作区。<br>如果失败（如冲突），会生成 .rej 文件记录拒绝的修改。<br><br>检查 Patch 是否可应用：<br>git apply --check my_patch.patch<br><br></code></pre></td></tr></table></figure><p>2.使用 git am</p><p>应用 Patch 并保留提交历史：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>git am my_patch.patch<br>会将 Patch 中的修改应用到代码库，并创建一个新的提交，保留原始提交信息（作者、时间、提交消息）。<br><br>如果应用过程中出现冲突，Git 会提示冲突文件。解决冲突后，使用以下命令继续：<br>git add &lt;conflict-file&gt;<br>git am --<span class="hljs-built_in">continue</span><br><br></code></pre></td></tr></table></figure><p>3.使用 patch 命令</p><p>适用于非 Git 管理的文件或更复杂的路径处理：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">patch -p1 &lt; my_patch.patch<br>-p1 表示剥离路径名的第一层（例如，将 /path/to/file.txt 转换为 to/file.txt）。<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工程链</category>
      
      <category>好用工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>树莓派5使用串口登录</title>
    <link href="/posts/f9fcbfe2.html"/>
    <url>/posts/f9fcbfe2.html</url>
    
    <content type="html"><![CDATA[<h1 id="树莓派5使用串口登录"><a href="#树莓派5使用串口登录" class="headerlink" title="树莓派5使用串口登录"></a>树莓派5使用串口登录</h1><ol><li>树莓派5上有一个专门的调试口，但是我试了很多方法都没办法用这个串口登录</li><li>找到一篇帖子，使用其他串口登录，可行，还不用买那个特别的接口</li><li><a href="https://www.chenxublog.com/2024/05/10/raspberry-pi-5-uart-ssh-no-data.html">https://www.chenxublog.com/2024/05/10/raspberry-pi-5-uart-ssh-no-data.html</a></li></ol><pre><code class="hljs">// 开启串口登录// 修改/boot/firmware/cmdline.txtconsole=ttyAMA0,115200 console=tty1// 修改/boot/firmware/config.txtenable_uart=1dtparam=uart0dtparam=uart0_console// 开启开机日志打印// 修改/boot/firmware/config.txtuart_2ndstage=1// 修改cmdline.txt，去掉quiet```bash</code></pre>]]></content>
    
    
    <categories>
      
      <category>工程链</category>
      
      <category>问题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>树莓派5配置WIFI</title>
    <link href="/posts/4be71e.html"/>
    <url>/posts/4be71e.html</url>
    
    <content type="html"><![CDATA[<h1 id="树莓派5配置wifi"><a href="#树莓派5配置wifi" class="headerlink" title="树莓派5配置wifi"></a>树莓派5配置wifi</h1><h2 id="现象："><a href="#现象：" class="headerlink" title="现象："></a>现象：</h2><ol><li>树莓派5烧录镜像时，配置了wifi，但是我想修改wifi</li><li>按照网上教程修改wpa_supplicant.conf文件，还是连接到原先的wifi上</li></ol><h2 id="定位："><a href="#定位：" class="headerlink" title="定位："></a>定位：</h2><ol><li>找到一篇帖子：<a href="https://forums.raspberrypi.com/viewtopic.php?t=371178">https://forums.raspberrypi.com/viewtopic.php?t=371178</a></li><li>意思是RasPiOS Bookworm这个系统已经不再使用wpa_supplicant管理网络了</li><li>查看了下我的系统，是Bookworm，网络管理工具是NetworkManager</li><li>参考这篇帖子，<a href="https://blog.csdn.net/qq_33919450/article/details/134258422">https://blog.csdn.net/qq_33919450/article/details/134258422</a></li></ol><h2 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h2><pre><code class="hljs">// 查看系统版本cat /etc/os-release// 查看连接状态nmcli connection show// 扫描可用的wifisudo nmcli dev wifi list// 连接指定wifinmcli dev wifi connect &quot;hello&quot; password &quot;123456&quot; ifname wlan0// 列出已配置网络的优先级nmcli -f NAME,TYPE,AUTOCONNECT-PRIORITY connection show// 设置 myWIFI1 为最高优先级（例如 10）sudo nmcli connection modify &quot;myWIFI1&quot; connection.autoconnect-priority 10// 重启 NetworkManager 服务sudo systemctl restart NetworkManager```bash</code></pre>]]></content>
    
    
    <categories>
      
      <category>工程链</category>
      
      <category>问题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>电子工程师核心技能树</title>
    <link href="/posts/eaa58a8b.html"/>
    <url>/posts/eaa58a8b.html</url>
    
    <content type="html"><![CDATA[<h1 id="电子工程师核心技能树"><a href="#电子工程师核心技能树" class="headerlink" title="电子工程师核心技能树"></a>电子工程师核心技能树</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>电子工程师的核心职责是通过应用电子技术和计算机技术，开发满足实际需求的电子产品或系统。</p><h2 id="核心技能"><a href="#核心技能" class="headerlink" title="核心技能"></a>核心技能</h2><p>我认为专业的电子工程师应该煅炼这三个方面的技能：</p><p>1.技术栈：通用的电子开发技术以及特定行业的深度技术<br>2.工程链：除了技术能力外，还应该具有一些软技能，推进项目的交付<br>3.应用面：技术栈和工程链是解决怎么做的问题，更重要的是知道做什么</p><h2 id="进阶之路"><a href="#进阶之路" class="headerlink" title="进阶之路"></a>进阶之路</h2><p>我们应该做解决方案工程师，而不是电脑后的代码工具<br>利用技术这个工具，去解决现实世界的问题，提供解决方案而不仅仅是代码</p><p>1.初级工程师</p><ul><li>掌握基本开发技能，能够在现有代码上做维护</li><li>参与项目开发，完成交代的任务</li></ul><p>2.中级工程师</p><ul><li>具备独立调试、解决问题的能力</li><li>能够独立完成或者主导项目开发、性能优化</li></ul><p>3.高级工程师</p><ul><li>主导整体方案设计，把控项目的进度和质量</li><li>提供这个行业的解决方案，挑战创新方案并量产</li></ul><h2 id="技能树"><a href="#技能树" class="headerlink" title="技能树"></a>技能树</h2><p>1.技术栈</p><p>1.1 MCU<br>1.2 Language<br>1.3 RTOS<br>1.4 Linux<br>1.5 Algorithm<br>1.6 IOT<br>1.7 GUI<br>1.8 Client<br>1.9 Server</p><p>2.工程链</p><p>2.1 调试技巧<br>2.2 软件设计<br>2.3 项目管理<br>2.4 问题记录<br>2.5 好用工具</p><p>3.应用面</p><p>3.1 行业动态<br>3.2 技术趋势<br>3.3 职业规划</p>]]></content>
    
    
    <categories>
      
      <category>应用面</category>
      
      <category>职业规划</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式系统主流芯片厂商</title>
    <link href="/posts/88c972ee.html"/>
    <url>/posts/88c972ee.html</url>
    
    <content type="html"><![CDATA[<h1 id="嵌入式系统主流芯片厂商"><a href="#嵌入式系统主流芯片厂商" class="headerlink" title="嵌入式系统主流芯片厂商"></a>嵌入式系统主流芯片厂商</h1><h2 id="一、国内厂商"><a href="#一、国内厂商" class="headerlink" title="一、国内厂商"></a>一、国内厂商</h2><h3 id="1-1-MCU原厂"><a href="#1-1-MCU原厂" class="headerlink" title="1.1 MCU原厂"></a>1.1 MCU原厂</h3><ol><li><p><strong>兆易创新（GigaDevice）</strong>  </p><ul><li>核心技术：基于ARM Cortex-M和RISC-V内核的通用MCU，兼容STM32生态，支持AI加速  </li><li>代表产品：GD32系列（如GD32H7，主频600MHz）、车规级BF7006系列  </li><li>应用领域：工业控制、汽车电子（ADAS、车载充电）、消费电子  </li><li>优势：国内32位MCU龙头，累计出货超10亿颗，覆盖工规、车规及消费级市场</li></ul></li><li><p><strong>中颖电子（Sinowealth）</strong>  </p><ul><li>核心技术：家电主控MCU、锂电池管理芯片  </li><li>代表产品：BM32系列（白色家电主控）、AMOLED驱动芯片  </li><li>应用领域：美的、海尔等家电品牌，电动工具、智能穿戴  </li><li>优势：高性价比、高可靠性，国产家电MCU市占率领先</li></ul></li><li><p><strong>国民技术（Nations）</strong>  </p><ul><li>核心技术：安全MCU、车规级芯片  </li><li>代表产品：N32系列（高性能通用MCU）、车规级BMS芯片  </li><li>应用领域：物联网安全、工业控制、汽车电子  </li><li>优势：实施”通用+安全”战略，布局高端车规市场</li></ul></li><li><p><strong>比亚迪半导体（BYD Semiconductor）</strong>  </p><ul><li>核心技术：车规级MCU、功率半导体  </li><li>代表产品：BF系列车规MCU（如BF7006）  </li><li>应用领域：新能源汽车电池管理、电机控制  </li><li>优势：自研40nm工艺，支持OTA升级</li></ul></li><li><p><strong>华大半导体&#x2F;小华半导体</strong>  </p><ul><li>核心技术：超低功耗MCU、车规级芯片  </li><li>代表产品：HC32系列（工业控制）、汽车MCU  </li><li>应用领域：智能电网、工业自动化、汽车电子  </li><li>优势：通过车规认证，覆盖安全物联网场景</li></ul></li><li><p><strong>沁恒微电子（WCH）</strong>  </p><ul><li>核心技术：RISC-V架构MCU，高集成度USB接口设计  </li><li>代表产品：CH32系列（RISC-V）、CH55x（8位USB MCU）  </li><li>应用领域：无线键鼠、Type-C扩展坞、工控设备  </li><li>优势：USB领域技术领先，RISC-V产品性价比突出</li></ul></li><li><p><strong>其他MCU厂商</strong>  </p><ul><li>极海半导体（Geehy）：APM32系列通用MCU，支持工业物联网安全  </li><li>复旦微电（FM）：低功耗MCU累计出货超千万颗，覆盖智能表计、电网终端  </li><li>灵动微电子：基于RISC-V内核的高性能MCU，主攻电机控制  </li><li>芯海科技（ChipSEA）：高精度ADC+MCU，应用于智能电表、医疗设备</li></ul></li></ol><hr><h3 id="1-2-SOC原厂"><a href="#1-2-SOC原厂" class="headerlink" title="1.2 SOC原厂"></a>1.2 SOC原厂</h3><h4 id="1-2-1-消费电子与通用领域"><a href="#1-2-1-消费电子与通用领域" class="headerlink" title="1.2.1 消费电子与通用领域"></a>1.2.1 消费电子与通用领域</h4><ol><li><p><strong>华为海思</strong>  </p><ul><li>核心技术：5G通信、AI运算、自研CPU&#x2F;GPU&#x2F;NPU架构、达芬奇AI架构、先进制程工艺（如5nm）  </li><li>代表产品：麒麟系列（麒麟990、麒麟9000、麒麟9020）、昇腾系列AI芯片（昇腾910、昇腾310）、巴龙系列基带芯片、鲲鹏服务器芯片  </li><li>应用领域：智能手机、AI服务器、数据中心、智能汽车、安防监控  </li><li>优势：全球首款5G SoC芯片，端侧AI算力领先，生态整合能力强，但受高端芯片制造限制</li></ul></li><li><p><strong>紫光展锐</strong>  </p><ul><li>核心技术：全场景通信技术（2G-6G、Wi-Fi、蓝牙、卫星通信）、RISC-V架构、5G R16特性支持  </li><li>代表产品：T系列手机芯片（T770、T760）、V系列物联网芯片（V620）、A7870智能座舱芯片  </li><li>应用领域：中低端智能手机、物联网设备、车联网、工业网关  </li><li>优势：全球公开市场5G芯片三强之一，性价比突出，但高端市场竞争力较弱</li></ul></li><li><p><strong>瑞芯微</strong>  </p><ul><li>核心技术：AIoT SoC设计、8K视频编解码、NPU加速（6TOPs算力）  </li><li>代表产品：RK3588（8nm旗舰SoC）、RK3576（边缘计算芯片）、RV1126（机器视觉芯片）  </li><li>应用领域：智能座舱、边缘计算、安防监控、扫地机器人、教育硬件  </li><li>优势：国产替代主力，RK3588对标高通骁龙，在低功耗与算力平衡上表现优异</li></ul></li><li><p><strong>全志科技</strong>  </p><ul><li>核心技术：RISC-V架构、智能座舱芯片设计、AI语音交互  </li><li>代表产品：T527（车载芯片）、R128（AI语音芯片）、MR系列（扫地机器人芯片）  </li><li>应用领域：智能车载、智能家居、工业控制、低端消费电子  </li><li>优势：车载中控芯片市占率40%，与小米、宇树科技深度合作，性价比高</li></ul></li><li><p><strong>晶晨股份</strong>  </p><ul><li>核心技术：超高清视频编解码（8K）、边缘AI、Wi-Fi 6&#x2F;蓝牙集成  </li><li>代表产品：6nm AI机顶盒芯片、T系列智能电视SoC、车载芯片A系列  </li><li>应用领域：智能机顶盒（全球份额领先）、智能电视、智能座舱  </li><li>优势：8K机顶盒芯片市占率100%，海外市场拓展迅速，技术壁垒高</li></ul></li><li><p><strong>恒玄科技</strong>  </p><ul><li>核心技术：低功耗蓝牙音频、AI降噪、多模态交互  </li><li>代表产品：BES2500系列（TWS耳机芯片）、BES2300（Wi-Fi&#x2F;蓝牙双模芯片）  </li><li>应用领域：TWS耳机、智能手表、智能家居  </li><li>优势：全球TWS耳机芯片市占率30%，客户覆盖华为、小米、三星</li></ul></li></ol><hr><h4 id="1-2-2-汽车电子领域"><a href="#1-2-2-汽车电子领域" class="headerlink" title="1.2.2 汽车电子领域"></a>1.2.2 汽车电子领域</h4><ol><li><p><strong>地平线</strong>  </p><ul><li>核心技术：自动驾驶AI芯片、算法工具链、多传感器融合  </li><li>代表产品：征程系列（征程5、征程6，支持L2-L4级自动驾驶）  </li><li>应用领域：智能驾驶域控制器、车载计算平台  </li><li>优势：国内头部自动驾驶芯片厂商，合作车企超40家，生态成熟</li></ul></li><li><p><strong>黑芝麻智能</strong>  </p><ul><li>核心技术：大算力自动驾驶芯片、车规级功能安全（ASIL-D）  </li><li>代表产品：华山系列（A1000、A2000）、武当系列（跨域计算芯片）  </li><li>应用领域：高阶自动驾驶、智能座舱、车路协同  </li><li>优势：算力达200TOPS，支持多芯片级联，与一汽、吉利深度合作</li></ul></li><li><p><strong>芯擎科技</strong>  </p><ul><li>核心技术：7nm车规级SoC、舱驾一体芯片设计  </li><li>代表产品：龍鷹一号（智能座舱芯片）、AD系列（自动驾驶芯片）  </li><li>应用领域：智能座舱、自动驾驶域控制器  </li><li>优势：填补国内高端车规芯片空白，与一汽成立联合实验室</li></ul></li><li><p><strong>芯驰科技</strong>  </p><ul><li>核心技术：智能座舱、中央网关、自动驾驶芯片  </li><li>代表产品：X9系列（智能座舱芯片）、V9系列（自动驾驶芯片）  </li><li>应用领域：车载娱乐系统、车身控制、域融合架构  </li><li>优势：通过ASIL-D认证，客户包括上汽、比亚迪</li></ul></li></ol><hr><h4 id="1-2-3-安防与视频处理领域"><a href="#1-2-3-安防与视频处理领域" class="headerlink" title="1.2.3 安防与视频处理领域"></a>1.2.3 安防与视频处理领域</h4><ol><li><p><strong>富瀚微</strong>  </p><ul><li>核心技术：视频编解码、图像信号处理（ISP）、低照度成像  </li><li>代表产品：FH8830（车载前装芯片）、FH8862（安防监控SoC）  </li><li>应用领域：安防摄像头、行车记录仪、智能家居  </li><li>优势：国内安防ISP龙头，技术适配海康威视、大华</li></ul></li><li><p><strong>星宸科技</strong>  </p><ul><li>核心技术：安防视频处理、AI算法、NVR SoC集成  </li><li>代表产品：SSC336D（IPC SoC）、SigmaStar系列（NVR芯片）  </li><li>应用领域：安防监控、智能门禁、视频会议  </li><li>优势：NVR芯片出货量国内第一，性价比突出</li></ul></li><li><p><strong>国科微</strong>  </p><ul><li>核心技术：H.265&#x2F;H.266编码、AI视觉处理  </li><li>代表产品：GK7606V1（4K AI视觉芯片）、GK7205（智能安防SoC）  </li><li>应用领域：智能安防、智慧城市、工业检测  </li><li>优势：支持多路视频分析，算法与硬件协同优化</li></ul></li></ol><hr><h4 id="1-2-4-AI与边缘计算领域"><a href="#1-2-4-AI与边缘计算领域" class="headerlink" title="1.2.4 AI与边缘计算领域"></a>1.2.4 AI与边缘计算领域</h4><ol><li><p><strong>北京君正</strong>  </p><ul><li>核心技术：低功耗计算、多媒体编解码、RISC-V架构  </li><li>代表产品：T系列（智能穿戴芯片）、X系列（边缘计算SoC）  </li><li>应用领域：可穿戴设备、智能家居、工业视觉  </li><li>优势：功耗控制优异，适配AI轻量化模型</li></ul></li><li><p><strong>云天励飞</strong>  </p><ul><li>核心技术：计算机视觉、端云协同AI、大模型推理  </li><li>代表产品：DeepEdge10（边缘AI芯片）、城市治理解决方案  </li><li>应用领域：安防监控、智慧交通、零售分析  </li><li>优势：算法与芯片协同设计，落地场景丰富</li></ul></li><li><p><strong>爱芯元智</strong>  </p><ul><li>核心技术：混合精度NPU、多模态感知  </li><li>代表产品：AX630A（视觉芯片）、M76H（智驾芯片）  </li><li>应用领域：智能驾驶、机器人、智能安防  </li><li>优势：支持L2+级自动驾驶，与黑芝麻智能战略合作</li></ul></li></ol><hr><h3 id="1-3-总结"><a href="#1-3-总结" class="headerlink" title="1.3 总结"></a>1.3 总结</h3><ul><li><strong>MCU厂商</strong>：聚焦工业控制、汽车电子和消费电子，兆易创新、中颖电子等占据中低端市场，比亚迪、华大半导体加速车规级布局  </li><li><strong>SOC厂商</strong>：瑞芯微、全志科技覆盖智能终端与车载场景，地平线、黑芝麻智能主攻边缘AI与自动驾驶  </li><li><strong>技术趋势</strong>：RISC-V架构（沁恒、灵动微）、车规级芯片（比亚迪、芯驰）是国产替代重点方向、边缘AI芯片</li></ul><hr><h2 id="二、国外厂商"><a href="#二、国外厂商" class="headerlink" title="二、国外厂商"></a>二、国外厂商</h2><h3 id="2-1-美国"><a href="#2-1-美国" class="headerlink" title="2.1. 美国"></a>2.1. 美国</h3><ul><li><p><strong>德州仪器（TI）</strong>  </p><ul><li>核心技术：模拟信号处理、超低功耗设计  </li><li>代表产品：MSP430（低功耗MCU）、C2000（实时控制MCU）  </li><li>应用领域：工业自动化、数字电源、物联网传感器  </li><li>优势：工业与汽车电子市占率第一，高可靠性电源管理方案</li></ul></li><li><p><strong>微芯科技（Microchip）</strong>  </p><ul><li>核心技术：PIC&#x2F;AVR架构MCU，高环境适应性（-40℃~125℃）  </li><li>代表产品：PIC系列（8&#x2F;16&#x2F;32位）、ATmega系列  </li><li>应用领域：严苛工业环境、汽车电子  </li><li>优势：成本优化设计，OTP器件安全性高</li></ul></li></ul><h3 id="2-2-欧洲"><a href="#2-2-欧洲" class="headerlink" title="2.2. 欧洲"></a>2.2. 欧洲</h3><ul><li><p><strong>意法半导体（ST）</strong>  </p><ul><li>核心技术：ARM Cortex-M系列MCU，多核异构设计  </li><li>代表产品：STM32系列（如STM32F4、STM32H7）  </li><li>应用领域：消费电子、工业自动化、智能家居  </li><li>优势：生态成熟，开发工具（STM32 Cube）支持完善</li></ul></li><li><p><strong>恩智浦（NXP）</strong>  </p><ul><li>核心技术：车规级MCU（ASIL-D安全等级），多协议无线连接  </li><li>代表产品：S32K系列（汽车MCU）、i.MX RT跨界处理器  </li><li>应用领域：车身控制、智能座舱、工业网关  </li><li>优势：全球最大汽车半导体供应商之一，功能安全认证齐全</li></ul></li><li><p><strong>英飞凌（Infineon）</strong>  </p><ul><li>核心技术：多核安全MCU，碳化硅（SiC）功率器件  </li><li>代表产品：AURIX系列（车规MCU）  </li><li>应用领域：自动驾驶、新能源车电控系统  </li><li>优势：支持ASIL-D安全等级，车用MCU市占率近30%</li></ul></li></ul><h3 id="2-3-日韩"><a href="#2-3-日韩" class="headerlink" title="2.3. 日韩"></a>2.3. 日韩</h3><ul><li><strong>瑞萨电子（Renesas）</strong>  <ul><li>核心技术：自研RX&#x2F;RH850内核，车规级MCU设计  </li><li>代表产品：RH850（车载MCU）、RA系列（ARM Cortex-M）  </li><li>应用领域：汽车动力系统、工业机器人  </li><li>优势：车用MCU全球市占率第一，整合NEC与三菱技术</li></ul></li></ul><hr><h2 id="三、国内外厂商对比与趋势"><a href="#三、国内外厂商对比与趋势" class="headerlink" title="三、国内外厂商对比与趋势"></a>三、国内外厂商对比与趋势</h2><h3 id="3-1-市场占有率"><a href="#3-1-市场占有率" class="headerlink" title="3.1. 市场占有率"></a>3.1. 市场占有率</h3><ul><li><p><strong>外资主导格局</strong>：<br>全球MCU市场前六大外资厂商（意法半导体、瑞萨、恩智浦、英飞凌、微芯科技、德州仪器）占据80%-88%份额。<br>中国市场中，外资厂商合计占据70%-85%，车规级MCU市占率超95%。  </p></li><li><p><strong>国产化进展</strong>：<br>2022年国内MCU国产化率约10%-15%，预计2024年可能提升至31%。</p></li></ul><h3 id="3-2-优势领域"><a href="#3-2-优势领域" class="headerlink" title="3.2. 优势领域"></a>3.2. 优势领域</h3><ul><li><p><strong>国内</strong>：  </p><ul><li>消费电子与物联网：兆易创新、乐鑫等以高性价比和快速迭代占据市场  </li><li>边缘AI：地平线、平头哥（玄铁RISC-V）在自动驾驶和AIoT领域突破</li></ul></li><li><p><strong>国外</strong>：  </p><ul><li>车规级芯片：瑞萨、英飞凌、恩智浦垄断高端市场  </li><li>工业与高可靠性：ST、TI的MCU生态成熟，支持复杂工业场景</li></ul></li></ul><h3 id="3-3-未来趋势"><a href="#3-3-未来趋势" class="headerlink" title="3.3 未来趋势"></a>3.3 未来趋势</h3><ol><li><p><strong>RISC-V架构加速国产化替代</strong>  </p><ul><li>阿里平头哥（玄铁系列出货超40亿颗）、赛昉科技推动开源生态  </li><li>2024年全球RISC-V MCU出货占比达12%，预计2025年突破20%</li></ul></li><li><p><strong>垂直整合深化</strong>  </p><ul><li>航顺芯片推出”MCPU”集成传感器、无线连接、安全模块  </li><li>STM32NanoEdge AI实现1mW端侧推理能力</li></ul></li><li><p><strong>车规级MCU国产化提速</strong>  </p><ul><li>工信部目标2025年国产车规MCU渗透率提升至20%  </li><li>芯驰科技E3系列通过ASIL-D认证，切入动力底盘域控制器市场</li></ul></li><li><p><strong>AI原生MCU重塑竞争格局</strong>  </p><ul><li>英飞凌AURIX TC5x采用16nm FinFET工艺  </li><li>兆易创新GD32H7集成NPU，算力达500 DMIPS</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>应用面</category>
      
      <category>行业方案</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
